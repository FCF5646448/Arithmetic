### 线性结构
数组、链表、栈、队列、哈希表
* 数组 数组的元素是连续的；
1、动态数组的实现。如何扩容？
因为每一次创建数组都是用new在堆中申请一块连续的内存。所以如果数组长度不够的话，则需要**重新生成一个新的数组**，新数组的容量大小可以是原数组的1.5倍。然后将当前数组中的元素拷贝进新的数组中。
2、元素删除，由于数组元素删除的话，需要把后面所有的元素都往前移动。所以可以考虑将删除的位置标记一下，以避免后续所有元素都进行移动。

* 链表

* 栈
* 队列
* 哈希表

### 树形结构
* 二叉树：

  * 最大度为2的树；

  * 非空二叉树的第i层，最多有2^(i-1)个节点（i>=1）;

  * 高度为h的二叉树，最多有2^(h) - 1个节点（h>=1）;

  * 对于任意一个非空二叉树，如果叶子节点个数为n0,度为2的节点个数为n2，则有**n0=n2+1**;

* 完全二叉树：
  * 所有节点除了最后一层，都是满的二叉树。且最后一层叶子节点靠左对齐。
  * 度为1的节点，最多只有一个。而且它是其父节点的左子树。
  * 如果一颗完全二叉树的高度是h，那么它最少有2^(h-1)个节点(2^0+2^1+2^2+...+2^(h-2)+1)
  * 总节点数为n，那么它的h=floor(log..n) + 1 。floor是向下取整。
  * 如果一个完全二叉树从上到下、从左往右对节点从0开始编号，则任意一个节点，它的父节点编号为floor((i-1)/2)，它的左子节点编号2i+1,右子节点编号为2i+2;
  * 如果一个完全二叉树节点为n，则它的叶子节点是(n+1)/2；非叶子节点是n/2；

* AVL树:

  因为一个二叉搜索树的搜索时间复杂度与高度息息相关，一般来说二叉搜索树的时间复杂度是O(logn)，但是最坏的时间复杂度就是O(h)，也就是每一个层级都比较一次。但是如果一个二叉搜索树退化成了链表，那么时间复杂度就相当于是O(n)。所以对二叉搜索树最好的改进就是用尽量少的调整让二叉树达到适度平衡即可。AVL树则是一个自平衡二叉搜索树之一。平衡因子：某节点的左右子树的高度差，AVL树的平衡因子只可能是0、1、-1。删除、搜索、添加的时间复杂度是O(logn)

  平衡操作：

  假设有一棵树，G是当前树的根节点，p是G的子节点，n是p的子节点。

  * LL—右旋转：LL是指p是G的左节点，n是p的左节点。然后改变n的高度（增加），导致G节点失去平衡；处理方式就是让G节点右旋转，过程：g.left = p.right; p.right = G；让p成为这棵树的根节点；
  * RR—左旋转：RR是指p是G的右节点，n是p的右节点。然后改变n的高度（增加），导致G节点失去平衡；处理方式就是让G节点左旋转，过程：g.right = p.left; p.left = G; 让p成为这棵树的根节点；
  * LR—先p左旋转，然后G右旋转：LR是指p是G的左节点，n是p的右节点。然后改变n的高度（增加），导致G失去平衡。处理过程是先对p节点进行左旋，然后对G节点进行右旋，过程：1、p.right = n.left; n.left=p;G.left = n;  2、G.left = n.right; n.right = G; 让n成为这棵树的根节点；
  * RL—先p右旋转，然后G左旋转；RL是指p是G的右节点，n是p的左节点。然后改变n的高度（增加），导致G失去平衡。处理过程是先对p节点进行右旋，然后对G节点进行左旋，过程：1、p.left = n.right; n.right = p; G.right = n; 2、G.right = n.left; n.left = G; 让n成为这棵树的根节点；

* 红黑树

* B树

* 二叉堆：

  **大顶堆**：根节点最大，所有父节点都大于其子节点；**小顶堆**：根节点最小，所有父节点都小于其子节点；二叉堆其实就是一个完全二叉树；二叉堆的底层一般用数组实现；

  索引i：

  * 如果 i == 0，它是根节点

  * i > 0 ，它的父节点编号是 (i - 1) / 2

  * 第一个非叶子节点的索引是 size / 2；

  **topK问题**：从n个整数中，找出最大的前k个数（k远远小于n，比如从100亿个数值中，找出前最大的1000个元素）。时间复杂度O(nlogk)的时间复杂度。其次，找出最大的k个数，其实是用小顶堆解决，这样每次只需先跟堆顶比较，然后再考虑下虑操作。

  

* Trie

* 哈夫曼树


### 图形结构
