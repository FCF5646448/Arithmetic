###  回溯

最好的回溯算法例子就是走岔路口
当走到某一个岔路口的时候，会判断哪条路能走到下一个路口，如果存在这样的路口，就继续往下一个路口走，如果存在多个这样的路口，那可以随机选一条路口走；如果不存在这样的路口，则返回上一入口，接着在上一个路口里查找是否存在能走到下一个插口的路，如果存在，则继续走，如果不存在，则再返回到上一岔口。

一般回溯的问题分为3种：
* 有没有解
* 求所有解（所有解的个数、所有解的具体信息）
* 求最优解

#### 解法
如果把上面的每一个岔路口都看做是一个节点Node，
##### 有没有解
这种问题直接返回 true / false 就好了。
这种就是条路走到黑，直到查找到结果为止。
```
Bool solve(n: Node) {
    if n 是否叶子节点 {
        if n 符合查找条件 {
            return true
        }
        reutrn false
    }
    for child in n.children {
        if solve(child) {
            // 说明符合条件
            return true
        }
    }
    return falase
}
```

##### 求所有解
这种问题需要设置全局变量，求个数使用count，求所有解使用results。
这种问题就得把所有问题都遍历一遍，但是遇到有问题的节点
```
var result: [Node] = []
void solve(n: Node) {
    if n 符合条件 
}
```



