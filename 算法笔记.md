##数据结构与算法

### 线性结构

指按一定的线性顺序排列而成的数据集合。

常见的数据结构：数组、链表、栈、队列、哈希表

#### 数组

* 数组的元素是连续的；
  1、动态数组的实现。如何扩容？
  因为每一次创建数组都是用new在堆中申请一块连续的内存。所以如果数组长度不够的话，则需要**重新生成一个新的数组**，新数组的容量大小可以是原数组的1.5倍。然后将当前数组中的元素拷贝进新的数组中。
  2、元素删除，由于数组元素删除的话，需要把后面所有的元素都往前移动。所以可以考虑将删除的位置标记一下，以避免后续所有元素都进行移动。

* 技巧：
	* 中心索引，利用中心索引左侧元素的和与所有元素的和的关系。
	* 二分法：while (l <= r) { mid = (l + r)/2 ; 右移：l = mid + 1; 左移：r = mid - 1}
	*   
* 二维数组：
	* 旋转矩阵： 
#### 链表 

  解题技巧：虚拟头节点、快慢指针、多指针；

* 栈

* 队列

* 哈希表

### 树形结构
* 二叉树：

  * 最大度为2的树；

  * 非空二叉树的第i层，最多有2^(i-1)个节点（i>=1）;

  * 高度为h的二叉树，最多有2^(h) - 1个节点（h>=1）;

  * 对于任意一个非空二叉树，如果叶子节点个数为n0,度为2的节点个数为n2，则有**n0=n2+1**;

* 完全二叉树：
  * 所有节点除了最后一层，都是满的二叉树。且最后一层叶子节点靠左对齐。
  * 度为1的节点，最多只有一个。而且它是其父节点的左子树。
  * 如果一颗完全二叉树的高度是h，那么它最少有2^(h-1)个节点(2^0+2^1+2^2+...+2^(h-2)+1)
  * 总节点数为n，那么它的h=floor(log..n) + 1 。floor是向下取整。
  * 如果一个完全二叉树从上到下、从左往右对节点从0开始编号，则任意一个节点，它的父节点编号为floor((i-1)/2)，它的左子节点编号2i+1,右子节点编号为2i+2;
  * 如果一个完全二叉树节点为n，则它的叶子节点是(n+1)/2；非叶子节点是n/2；

* AVL树:

  因为一个二叉搜索树的搜索时间复杂度与高度息息相关，一般来说二叉搜索树的时间复杂度是O(logn)，但是最坏的时间复杂度就是O(h)，也就是每一个层级都比较一次。但是如果一个二叉搜索树退化成了链表，那么时间复杂度就相当于是O(n)。所以对二叉搜索树最好的改进就是用尽量少的调整让二叉树达到适度平衡即可。AVL树则是一个自平衡二叉搜索树之一。平衡因子：某节点的左右子树的高度差，AVL树的平衡因子只可能是0、1、-1。删除、搜索、添加的时间复杂度是O(logn)

  平衡操作：

  假设有一棵树，G是当前树的根节点，p是G的子节点，n是p的子节点。

  * LL—右旋转：LL是指p是G的左节点，n是p的左节点。然后改变n的高度（增加），导致G节点失去平衡；处理方式就是让G节点右旋转，过程：g.left = p.right; p.right = G；让p成为这棵树的根节点；
  * RR—左旋转：RR是指p是G的右节点，n是p的右节点。然后改变n的高度（增加），导致G节点失去平衡；处理方式就是让G节点左旋转，过程：g.right = p.left; p.left = G; 让p成为这棵树的根节点；
  * LR—先p左旋转，然后G右旋转：LR是指p是G的左节点，n是p的右节点。然后改变n的高度（增加），导致G失去平衡。处理过程是先对p节点进行左旋，然后对G节点进行右旋，过程：1、p.right = n.left; n.left=p;G.left = n;  2、G.left = n.right; n.right = G; 让n成为这棵树的根节点；
  * RL—先p右旋转，然后G左旋转；RL是指p是G的右节点，n是p的左节点。然后改变n的高度（增加），导致G失去平衡。处理过程是先对p节点进行右旋，然后对G节点进行左旋，过程：1、p.left = n.right; n.right = p; G.right = n; 2、G.right = n.left; n.left = G; 让n成为这棵树的根节点；

* B树:

  B树是一种平衡的多路搜索树，多用于文件系统和数据库，比如MySQL；m阶B树是指一个节点最多有m个节点。

  * 一个节点可以存储超过2个元素，可以拥有超过2个节点；

  * 拥有二叉搜索树的性质；

  * 每个节点的所有子树高度一致；

  * 假设一个节点存储的元素个数为x，根节点：1 <= x <= m-1；非根节点：如果有子节点，那子节点的个数y = x + 1；非根节点的子节点个数ceiling(m/2) <= y <= m；

  * 二叉搜索树其实就是2阶B树，二叉搜索树可以合并成一个B树，m代合并的超级节点最多拥有2^n个子节点；

  * 搜索方式与二叉搜索树类似，只是先在节点内部搜索，然后去子节点中搜索；

  * 上溢：添加节点后，节点数等于m，所以需要上溢；

    

* 红黑树

  红黑树也是一种自平衡的二叉搜索树。红黑树是一颗真二叉树（每个节点的度要么为0，要么为2，所有的叶子节点都是空节点(是假象的节点，不会真实添加进去)）;

  * 节点要么红色Red，要么黑色Black；
  * 根节点是Black，叶子节点（包括空节点）都是Black；
  * 红色Red节点的子节点和父节点必然是黑色Black；
  * 从任一节点到叶子节点(包括空节点)的所有路径都包含相同数目的黑色Black节点；
  * 红黑树和4阶B树(2-3-4树)具有等价性：Black节点与它的Red节点融合在一起，形成1个B树节点；红黑树的Black节点个数与4阶B树的节点个数相等；
  * 红黑树的元素必须具备可比较性。



* 二叉堆：

  **大顶堆**：根节点最大，所有父节点都大于其子节点；**小顶堆**：根节点最小，所有父节点都小于其子节点；二叉堆其实就是一个完全二叉树；二叉堆的底层一般用数组实现；

  索引i：

  * 如果 i == 0，它是根节点

  * i > 0 ，它的父节点编号是 (i - 1) / 2

  * 第一个非叶子节点的索引是 size / 2；

  **topK问题**：从n个整数中，找出最大的前k个数（k远远小于n，比如从100亿个数值中，找出前最大的1000个元素）。时间复杂度O(nlogk)的时间复杂度。其次，找出最大的k个数，其实是用小顶堆解决，这样每次只需先跟堆顶比较，然后再考虑下虑操作。

  

* Trie

* 哈夫曼树

* 并查集

### 图形结构

* 图

  G（V，E）,V表示顶点集合，E表示边的集合。边的集合E可以为空

  * 有向图的边是有明确方向的。**有向无环图**是指如果一个图是有向图，从任意顶点出发无法经过若干条边回到该顶点。
  * 入度是指有向图中有多少条边指向该顶点；出度是指有向图中该顶点有多少条边指向其他顶 点。
  * 完全图是指任意两个顶点都存在边。无向完全图的n个顶点的边是n(n-1)/2条边。
  * 有权图是指边拥有权值。
  * 如果顶点x和y之间存在相互抵达的路径，则称是**连通**的。如果无向图中任意2个顶点是连通的，则称G为**无向连通图**。
  * 连通分量：无向图的极大连通子图；连通图的连通分量就是其自身；非连通的无向图有多个连通分量。强连通图就是指有向图中任意两个顶点都能抵达的图，强连通分量是指强连通图的极大连通子图。
  * 邻接矩阵：一维数组存放顶点信息，二维数组存放边信息；邻接矩阵适合稠密图。
  * 邻接表：使用一个一维数组存放顶点信息，每个顶点有个next指针，指向邻接点；如果有权值，则节点就多一个权值。

  


## 算法

* 排序
  * 冒泡排序：相邻邻居交换，每一轮循环确定当前数据最大值；

  * 选择排序：每一次找到当前查找序列中的 最大值，然后与当前序列最后一个值交换，这样也是每一轮循环就确定一个最大值。

  * 堆排序：首先堆是一棵平衡二叉树，一般存储方式是使用数组按层次遍历的方式存储，也就是说真实的堆在数组中的表现形式是无序的且堆顶元素在数组的第一个元素。堆排序就是对已经建好的堆进行排序，排序的方式其实就是将堆顶元素与数组末尾元素进行交换，然后调整堆。说白了就是交换了之后的堆数组就变成了整个数组的一部分了。然后对堆数组持续重复交换与调整的操作，直到堆元素个数为0，这样数组就变成有序的了。

  * 插入排序：插入排序就类似打牌，数组前面的元素是已排好序的，每查找一个元素，就得将其插入到数组合适的位置中。插入排序的时间复杂度跟“逆序对”的数量成正比

  * 归并排序：

    归并排序的方式就是先将数组进行分割，分个到不能取mid为止，也就是数组中至少有3个元素（begin、mid、end）。分割完成后再进行合并，合并的话注意使用一个零时数组暂存左半部分元素。然后依次将零时数组元素、右半部分的元素，按序放到数组中。（注意各个数组的下标计算与初始值）

  * 快速排序：

    本质就是逐渐将每一个元素转成轴点元素。

    选择一个轴点元素，将小于轴点的所有元素移到轴点的左侧；将每一个大于轴点的所有元素都移到右侧。

    
    
## 算法技巧
### 递归
* 理解函数调用过程，每个函数调用时，都会分配一段连续的栈空间用于存放临时变量和参数，当函数调用结束时，这个连续内存空间就会被回收掉，回到原来的函数中执行下一步操作。
* 递归函数调用也是一样的，不断递归调用就意味着不断在内存中开辟一样的栈空间。所以递归必须有一个最终结束的条件。否则栈内存会被爆。
* 递归思想——**拆解问题**：把规模大的问题变成规模较小的同类型问题；把规模较小的问题分解成规模更小的问题；直到规模小到一定程度可以直接得出它的解。**求解**：由最小规模问题的解得出较大规模的解；由较大规模的解得出更大规模的解；直到得出原来问题的解。

### 回溯
每一次都查找到最深层，直到不满足条件就回溯查找下一个分支。
* 剪枝：去除无用的选项
* N皇后问题

### 贪心算法
每一步都采取当前状态下的最优的选择(局部最优解)，从而推导出全局最优解
但是贪心算法并不一定能得到全局最优解，因为一般没有测试所有可能的解，容易过早做决定，所以没法达到最佳解。
所以贪心算法一般作为其他算法的辅助算法。
比如：零钱兑换问题。

### 分治
将原问题分解成若干个规模较小的子问题，子问题又可以推导出更小的子问题，最后利用子问题的解推导出原问题的解。比如归并、快排。
所以分治算法非常适合用递归。


### 动态规划
动态规划是求解**最优**化的过程。比如最大、最小、最优等字眼。

动态规划一般的学习过程就是一步一步优化的过程：
* 1暴力递归（自顶向下，出现了重叠子问题）
* 2记忆化搜索（自顶向下）
* 3递推（自底向上）
总结：
动态规划中“动态”可以理解为“会变化的状态”
* 定义状态 (状态是原问题的解)。比如零钱问题里dp[i]就表示集齐i块钱所需最小硬币个数；
* 设置初始状态(边界)。比如设置dp[0]的值
* 确定状态转移方程。比如确定dp[i]和dp[i-1]的关系。

一般可以用动态规划来解决的问题，通常有2个特点：
* 最优子结构：通过求解子问题的最优解，可以得到原问题的最优解；
* 无后效行：后续阶段的解，只关心当前阶段的值，而不需关心当前阶段的具体过程。


#### 总结：动态规划三步骤：
**定义状态；**
**状态初始值；**
**状态转移方程；**






